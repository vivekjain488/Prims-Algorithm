<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Prim's Algorithm Visualizer</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(to right, #121212, #1e1e1e);
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      color: white;
    }

    h1 {
      margin-top: 20px;
      color: #00efa6;
      text-shadow: 0 0 10px rgba(0, 239, 166, 0.5);
      font-size: 2.5rem;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .controls, .edge-inputs, .run-prims {
      margin-top: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      align-items: center;
      background-color: rgba(0, 0, 0, 0.4);
      padding: 20px;
      border-radius: 15px;
      box-shadow: 0 4px 20px rgba(0, 239, 166, 0.2);
      border: 1px solid rgba(0, 239, 166, 0.3);
    }

    input[type="number"] {
      padding: 12px;
      border: 2px solid #00efa6;
      border-radius: 8px;
      font-size: 16px;
      width: 70px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      transition: all 0.3s ease;
    }

    input[type="number"]:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(0, 239, 166, 0.3);
    }

    button {
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      background-color: #00efa6;
      color: black;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    button:hover {
      background-color: #00c288;
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 239, 166, 0.4);
    }

    label {
      color: #00efa6;
      font-weight: bold;
    }

    canvas {
      border: 3px solid #00efa6;
      background: #121212;
      margin-top: 30px;
      box-shadow: 0 0 30px rgba(0, 239, 166, 0.3);
      border-radius: 10px;
    }

    table {
      margin-top: 30px;
      border-collapse: collapse;
      background: rgba(0, 0, 0, 0.6);
      box-shadow: 0 0 20px rgba(0, 239, 166, 0.2);
      border-radius: 10px;
      overflow: hidden;
      width: 800px;
    }

    th, td {
      border: 1px solid #00efa6;
      padding: 12px 15px;
      text-align: center;
    }

    th {
      background-color: #00efa6;
      color: black;
      text-transform: uppercase;
      font-weight: bold;
    }

    td {
      color: #ddd;
    }

    tr:nth-child(even) {
      background-color: rgba(0, 239, 166, 0.05);
    }

    .run-prims {
      margin-top: 20px;
      display: flex;
      justify-content: center;
    }

    .run-prims button {
      background-color: #00efa6;
      color: black;
      padding: 15px 30px;
      font-size: 18px;
      letter-spacing: 1px;
    }

    ::placeholder {
      color: #aaa;
    }

    /* Add this to your existing styles */
    #logTable {
      display: none;
      margin-top: 30px;
      border-collapse: collapse;
      background: rgba(0, 0, 0, 0.6);
      box-shadow: 0 0 20px rgba(0, 239, 166, 0.2);
      border-radius: 10px;
      overflow: hidden;
      width: 800px;
      animation: fadeIn 0.5s ease-in-out;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
  </style>
</head>
<body>
  <h1>Prim's Algorithm Visualizer</h1>
  <div class="controls">
    <label for="nodeCount">Nodes:</label>
    <input type="number" id="nodeCount" min="2" max="15" value="6" />
    <button onclick="generateGraph()">Generate Nodes</button>
  </div>
  <div class="edge-inputs">
    <input type="number" id="fromNode" placeholder="From" min="0" />
    <input type="number" id="toNode" placeholder="To" min="0" />
    <input type="number" id="weight" placeholder="Weight" min="1" />
    <button onclick="addEdge()">Add Edge</button>
    <!-- <button onclick="drawGraph()">Draw Graph</button> -->
  </div>
  <div class="run-prims">
    <button onclick="runPrims()">Run Prim's Algorithm</button>
  </div>

  <canvas id="graphCanvas" width="800" height="500"></canvas>

  <table id="logTable">
    <thead>
      <tr>
        <th>Step</th>
        <th>Current Node</th>
        <th>Available Edges</th>
        <th>Chosen Edge</th>
        <th>MST So Far</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
    const canvas = document.getElementById("graphCanvas");
    const ctx = canvas.getContext("2d");
    const logTable = document.getElementById("logTable").querySelector("tbody");
    let nodes = [];
    let edges = [];
    let mstEdges = [];

    class Node {
      constructor(x, y, id) {
        this.x = x;
        this.y = y;
        this.id = id;
      }
    }

    class Edge {
      constructor(from, to, weight) {
        this.from = from;
        this.to = to;
        this.weight = weight;
      }

      toString() {
        return `(${this.from}-${this.to}, w:${this.weight})`;
      }
    }

    function generateGraph() {
      const nodeCount = parseInt(document.getElementById("nodeCount").value);
      if (nodeCount < 2 || nodeCount > 15) return alert("Please enter a number between 2 and 15");

      nodes = [];
      edges = [];
      mstEdges = [];
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      logTable.innerHTML = '';

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = Math.min(canvas.width, canvas.height) / 3;

      for (let i = 0; i < nodeCount; i++) {
        const angle = (2 * Math.PI * i) / nodeCount;
        const x = centerX + radius * Math.cos(angle);
        const y = centerY + radius * Math.sin(angle);
        nodes.push(new Node(x, y, i + 1));
      }

      drawGraph();
    }

    function addEdge() {
      const from = parseInt(document.getElementById("fromNode").value);
      const to = parseInt(document.getElementById("toNode").value);
      const weight = parseInt(document.getElementById("weight").value);
    if (
        isNaN(from) || isNaN(to) || isNaN(weight) || 
        from === to || 
        from < 1 || to < 1 || 
        from > nodes.length || to > nodes.length
      ) {
        alert("Invalid edge input");
        return;
      }
      edges.push(new Edge(from - 1, to - 1, weight));
      drawGraph();
    }
    function drawGraph() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Step 1: First draw all regular edges (lines only)
      for (let edge of edges) {
        const fromNode = nodes[edge.from];
        const toNode = nodes[edge.to];
        const gradient = ctx.createLinearGradient(fromNode.x, fromNode.y, toNode.x, toNode.y);
        gradient.addColorStop(0, "rgba(0, 239, 166, 0.3)");
        gradient.addColorStop(0.5, "rgba(0, 239, 166, 0.5)");
        gradient.addColorStop(1, "rgba(0, 239, 166, 0.3)");
        
        ctx.beginPath();
        ctx.moveTo(fromNode.x, fromNode.y);
        ctx.lineTo(toNode.x, toNode.y);
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 5;
        ctx.stroke();
      }
      
      // Step 2: Draw all MST edges (lines only)
      for (let edge of mstEdges) {
        const fromNode = nodes[edge.from];
        const toNode = nodes[edge.to];
        const gradient = ctx.createLinearGradient(fromNode.x, fromNode.y, toNode.x, toNode.y);
        gradient.addColorStop(0, "#00efa6");
        gradient.addColorStop(0.5, "#00ffc3");
        gradient.addColorStop(1, "#00efa6");
        ctx.shadowColor = "#00efa6";
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.moveTo(fromNode.x, fromNode.y);
        ctx.lineTo(toNode.x, toNode.y);
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 4;
        ctx.stroke();
        ctx.shadowBlur = 0;
      }
      
      // Step 3: Draw all weight labels (on top of lines)
      for (let edge of edges) {
        const fromNode = nodes[edge.from];
        const toNode = nodes[edge.to];
        const midX = (fromNode.x + toNode.x) / 2;
        const midY = (fromNode.y + toNode.y) / 2;
        
        // Draw weight background for better readability
        ctx.beginPath();
        ctx.arc(midX, midY, 14, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
        ctx.fill();
        
        // Draw weight text
        ctx.shadowColor = "#00efa6";
        ctx.shadowBlur = 5;
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "bold 14px sans-serif";
        ctx.fillText(edge.weight, midX, midY);
        ctx.shadowBlur = 0;
      }
      
      // Step 4: Draw all nodes (on top of everything)
      for (let node of nodes) {
        ctx.beginPath();
        ctx.arc(node.x, node.y, 22, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(0, 239, 166, 0.2)";
        ctx.fill();
        ctx.beginPath();
        ctx.arc(node.x, node.y, 20, 0, Math.PI * 2);
        ctx.fillStyle = "#00efa6";
        ctx.fill();
        ctx.beginPath();
        ctx.arc(node.x, node.y, 18, 0, Math.PI * 2);
        ctx.fillStyle = "#00d696";
        ctx.fill();
        ctx.fillStyle = "black";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "bold 14px sans-serif";
        ctx.fillText(node.id, node.x, node.y);
      }
    }

    function runPrims() {
      if (nodes.length === 0 || edges.length === 0) {
        alert("Please generate nodes and add edges first");
        return;
      }

      // Clear previous MST
      mstEdges = [];
      
      // Make the table visible
      document.getElementById("logTable").style.display = "table";
      logTable.innerHTML = '';

      const visited = new Set();
      const pq = []; // Priority queue to store edges
      
      // Start with node 0 (which is displayed as node 1)
      visited.add(0);
      let step = 1;

      // Add all edges from the first node to the priority queue
      for (let edge of edges) {
        if (edge.from === 0 || edge.to === 0) {
          pq.push(edge);
        }
      }

      // Sort by weight
      pq.sort((a, b) => a.weight - b.weight);

      // Add a row for the initial state
      const initialRow = document.createElement("tr");
      initialRow.innerHTML = `
        <td>${step++}</td>
        <td>1</td>
        <td>${pq.map(e => formatEdge(e)).join(", ")}</td>
        <td>-</td>
        <td>-</td>
      `;
      logTable.appendChild(initialRow);

      // Run Prim's algorithm
      while (visited.size < nodes.length && pq.length > 0) {
        const edge = pq.shift();
        
        // Skip if both ends are already in the MST
        if (visited.has(edge.from) && visited.has(edge.to)) continue;

        // Add edge to MST
        mstEdges.push(edge);

        // Determine which node is new
        const newNode = visited.has(edge.from) ? edge.to : edge.from;
        visited.add(newNode);

        // Find all edges connected to the new node
        const availableEdges = [];
        for (let e of edges) {
          if ((e.from === newNode && !visited.has(e.to)) || (e.to === newNode && !visited.has(e.from))) {
            pq.push(e);
            availableEdges.push(e);
          }
        }

        // Sort by weight
        pq.sort((a, b) => a.weight - b.weight);

        // Add a row to the log table
        const row = document.createElement("tr");
        row.innerHTML = `
          <td>${step++}</td>
          <td>${newNode + 1}</td>
          <td>${pq.map(e => formatEdge(e)).join(", ")}</td>
          <td>${formatEdge(edge)}</td>
          <td>${mstEdges.map(e => formatEdge(e)).join(", ")}</td>
        `;
        logTable.appendChild(row);
      }

      drawGraph();
    }

    // Helper function to format edge display with 1-based indexing
    function formatEdge(edge) {
      return `(${edge.from + 1}-${edge.to + 1}, w:${edge.weight})`;
    }

    // Initial page load - hide the table
    document.addEventListener("DOMContentLoaded", function() {
      document.getElementById("logTable").style.display = "none";
    });
  </script>
</body>
</html>